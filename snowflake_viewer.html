<!DOCTYPE html>
<html>
<head>
    <title>Snowflake Tree Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #333;
            color: white;
            font-family: monospace;
        }
        #controls {
            margin-bottom: 20px;
        }
        #controls button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 14px;
        }
        #canvas {
            border: 1px solid #666;
            background: #1a1a2e;
        }
        .info {
            margin-top: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>Snowflake Tree Viewer</h1>
    <div id="controls">
        <button onclick="testMode(20)">Mode 20: Cross</button>
        <button onclick="testMode(21)">Mode 21: 12-arm</button>
        <button onclick="testMode(22)">Mode 22: 12-arm + center</button>
        <button onclick="testMode(23)">Mode 23: 6-arm</button>
        <button onclick="testMode(24)">Mode 24: Thick 6-arm</button>
        <button onclick="testMode(25)">Mode 25: 6-arm (30° view)</button>
        <button onclick="testMode(26)">Mode 26: 6-arm (60° view)</button>
        <button onclick="customSnowflake()">Custom Snowflake</button>
    </div>
    <canvas id="canvas" width="800" height="800"></canvas>
    <div class="info" id="info"></div>

    <script>
        let points = [];
        let colors = [];
        let center = [0, 0, 0];
        
        // Load tree points
        fetch('tree_points.json')
            .then(r => r.json())
            .then(data => {
                points = data;
                // Calculate center
                center = points.reduce((acc, p) => [acc[0]+p[0], acc[1]+p[1], acc[2]+p[2]], [0,0,0]);
                center = center.map(c => c / points.length);
                
                // Center all points
                points = points.map(p => [p[0]-center[0], p[1]-center[1], p[2]-center[2]]);
                
                colors = new Array(points.length).fill([10, 10, 40]);
                render();
                document.getElementById('info').textContent = `Loaded ${points.length} points`;
            });

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        function project3D(x, y, z, viewAngle = 45) {
            const angle = viewAngle * Math.PI / 180;
            const screenX = x * Math.cos(angle) - y * Math.sin(angle);
            const screenY = z;
            return [screenX, screenY];
        }
        
        function normalizeScreen(screenCoords) {
            const xs = screenCoords.map(c => c[0]);
            const ys = screenCoords.map(c => c[1]);
            const xRange = Math.max(...xs) - Math.min(...xs);
            const yRange = Math.max(...ys) - Math.min(...ys);
            const maxRange = Math.max(xRange, yRange);
            const xMean = (Math.max(...xs) + Math.min(...xs)) / 2;
            const yMean = (Math.max(...ys) + Math.min(...ys)) / 2;
            
            return screenCoords.map(([x, y]) => [
                (x - xMean) / maxRange,
                (y - yMean) / maxRange
            ]);
        }
        
        function distanceToLine(px, py, angleDeg) {
            const angle = angleDeg * Math.PI / 180;
            return Math.abs(px * Math.sin(angle) - py * Math.cos(angle));
        }
        
        function calculateSnowflake(mode, viewAngle = 45, lineWidth = 0.04) {
            // Project to screen space
            const screenCoords = points.map(p => project3D(p[0], p[1], p[2], viewAngle));
            const normalized = normalizeScreen(screenCoords);
            
            const newColors = points.map(() => [10, 10, 40]); // Dark background
            
            if (mode === 20) {
                // Cross
                normalized.forEach(([sx, sy], i) => {
                    if (Math.abs(sx) < lineWidth || Math.abs(sy) < lineWidth) {
                        newColors[i] = [255, 255, 255];
                    }
                });
            } else if (mode === 21) {
                // 12-arm
                normalized.forEach(([sx, sy], i) => {
                    for (let angle = 0; angle < 180; angle += 30) {
                        if (distanceToLine(sx, sy, angle) < lineWidth) {
                            newColors[i] = [255, 255, 255];
                            break;
                        }
                    }
                });
            } else if (mode === 22) {
                // 12-arm + center
                normalized.forEach(([sx, sy], i) => {
                    const dist = Math.sqrt(sx*sx + sy*sy);
                    if (dist < 0.08) {
                        newColors[i] = [255, 255, 255];
                    } else {
                        for (let angle = 0; angle < 180; angle += 30) {
                            if (distanceToLine(sx, sy, angle) < lineWidth) {
                                newColors[i] = [255, 255, 255];
                                break;
                            }
                        }
                    }
                });
            } else if (mode === 23) {
                // 6-arm (60° spacing)
                normalized.forEach(([sx, sy], i) => {
                    const dist = Math.sqrt(sx*sx + sy*sy);
                    if (dist < 0.08) {
                        newColors[i] = [255, 255, 255];
                    } else {
                        for (let angle = 0; angle < 180; angle += 60) {
                            if (distanceToLine(sx, sy, angle) < lineWidth) {
                                newColors[i] = [255, 255, 255];
                                break;
                            }
                        }
                    }
                });
            } else if (mode === 24) {
                // Thick 6-arm
                normalized.forEach(([sx, sy], i) => {
                    const dist = Math.sqrt(sx*sx + sy*sy);
                    if (dist < 0.10) {
                        newColors[i] = [255, 255, 255];
                    } else {
                        for (let angle = 0; angle < 180; angle += 60) {
                            if (distanceToLine(sx, sy, angle) < 0.06) {
                                newColors[i] = [255, 255, 255];
                                break;
                            }
                        }
                    }
                });
            } else if (mode === 25 || mode === 26) {
                // Different view angles
                const va = mode === 25 ? 30 : 60;
                const sc = points.map(p => project3D(p[0], p[1], p[2], va));
                const norm = normalizeScreen(sc);
                norm.forEach(([sx, sy], i) => {
                    const dist = Math.sqrt(sx*sx + sy*sy);
                    if (dist < 0.10) {
                        newColors[i] = [255, 255, 255];
                    } else {
                        for (let angle = 0; angle < 180; angle += 60) {
                            if (distanceToLine(sx, sy, angle) < 0.05) {
                                newColors[i] = [255, 255, 255];
                                break;
                            }
                        }
                    }
                });
            }
            
            return newColors;
        }
        
        function testMode(mode) {
            colors = calculateSnowflake(mode);
            render();
            document.getElementById('info').textContent = `Mode ${mode} - Lit: ${colors.filter(c => c[0] > 100).length} points`;
        }
        
        function customSnowflake() {
            // Better snowflake: use YZ plane projection (front view)
            const newColors = points.map(() => [10, 10, 40]);
            
            // For front view, use Y (horizontal) and Z (vertical)
            // Project to 2D: screen_x = y, screen_y = z
            const screenCoords = points.map(p => [p[1], p[2]]);
            
            // Normalize
            const xs = screenCoords.map(c => c[0]);
            const ys = screenCoords.map(c => c[1]);
            const xRange = Math.max(...xs) - Math.min(...xs);
            const yRange = Math.max(...ys) - Math.min(...ys);
            const maxRange = Math.max(xRange, yRange);
            const xMean = (Math.max(...xs) + Math.min(...xs)) / 2;
            const yMean = (Math.max(...ys) + Math.min(...ys)) / 2;
            
            const normalized = screenCoords.map(([x, y]) => [
                (x - xMean) / maxRange,
                (y - yMean) / maxRange
            ]);
            
            // 6-arm snowflake centered at (0, 0)
            normalized.forEach(([sx, sy], i) => {
                const dist = Math.sqrt(sx*sx + sy*sy);
                
                // Center dot
                if (dist < 0.10) {
                    newColors[i] = [255, 255, 255];
                } else {
                    // 6 arms at 60° intervals: 0°, 60°, 120°, 180°, 240°, 300°
                    // 0° = up (vertical), 60° = diagonal, etc.
                    for (let angle = 0; angle < 360; angle += 60) {
                        const a = angle * Math.PI / 180;
                        // Distance from line through origin at this angle
                        const lineDist = Math.abs(sx * Math.sin(a) - sy * Math.cos(a));
                        
                        if (lineDist < 0.04) {
                            // Check if point is in positive direction (outward from center)
                            const dot = sx * Math.cos(a) + sy * Math.sin(a);
                            if (dot > 0 && dist < 0.5) { // Only within reasonable distance
                                newColors[i] = [255, 255, 255];
                                break;
                            }
                        }
                    }
                }
            });
            
            colors = newColors;
            render();
            document.getElementById('info').textContent = `Custom (YZ plane) - Lit: ${colors.filter(c => c[0] > 100).length} points`;
        }
        
        function render() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Project points to screen
            const screenCoords = points.map(p => project3D(p[0], p[1], p[2], 45));
            const normalized = normalizeScreen(screenCoords);
            
            // Draw points
            normalized.forEach(([sx, sy], i) => {
                const [r, g, b] = colors[i];
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                const x = (sx + 0.5) * canvas.width;
                const y = (0.5 - sy) * canvas.height; // Flip Y
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    </script>
</body>
</html>

